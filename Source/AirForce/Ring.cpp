//------------------------------------------------------------------------
// ファイル名		:Ring.cpp
// 概要				:コースの進行先を示すリングのクラス
// 作成日			:2021/06/04
// 作成者			:19CU0105 池村凌太
// 更新内容			:2021/06/04
//------------------------------------------------------------------------


#include "Ring.h"
#include "Components/StaticMeshComponent.h"
#include "ColorLightComponent.h"
#include "Kismet/GameplayStatics.h"
#include "NiagaraComponent.h"
#include "NiagaraFunctionLibrary.h"
#include "DroneBase.h"

//コンストラクタ
ARing::ARing()
	: m_pColorLightComp(NULL)
	, m_pRingMesh(NULL)
	, m_RingNumber(0)
	, m_RingDrawUpNumber(0)
	, m_pNiagaraEffectComp(NULL)
	, m_bIsPassed(false)
	, m_MakeInvisibleCnt(0.f)
	, m_MakeInvisibleTime(1.8f)
{
	//カラーコンポーネント生成
	m_pColorLightComp = CreateDefaultSubobject<UColorLightComponent>(TEXT("m_pColorLightComp"));

	//メッシュ生成
	m_pRingMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("m_pRingMesh"));
	if (m_pRingMesh)
	{
		RootComponent = m_pRingMesh;
	}

	//ナイアガラのエフェクトコンポーネント生成
	m_pNiagaraEffectComp = CreateDefaultSubobject<UNiagaraComponent>(TEXT("m_pNiagaraEffectComp"));

	//毎フレームTickを呼び出すかどうかのフラグ
	PrimaryActorTick.bCanEverTick = true;
}

//ゲーム開始時またはこのクラスのオブジェクトがスポーンされた時１度だけ呼び出される関数
void ARing::BeginPlay()
{
	Super::BeginPlay();

	//オーバーラップ開始時に呼ばれるイベント関数を登録
	m_pRingMesh->OnComponentBeginOverlap.AddDynamic(this, &ARing::OnOverlapBegin);

	//	ドローンの検索
	TSubclassOf<AActor> findClass;
	findClass = AActor::StaticClass();
	TArray<AActor*> actors;
	UGameplayStatics::GetAllActorsOfClass(this->GetWorld(), findClass, actors);

	//検索範囲にActorがあれば
	if ((int)actors.Num() > 0)
	{
		for (int i = 0; i < (int)actors.Num(); i++)
		{
			//検索したアクター
			AActor* pActor = Cast<AActor>(actors[i]);

			//	ゲームマネジャーを取得
			if (pActor->ActorHasTag("Drone"))
			{
				m_Drone = Cast<ADroneBase>(pActor);
				break;
			}
		}
	}

	m_pColorLightComp->InitializeMaterialParameter(m_pRingMesh, true);
	m_pColorLightComp->Activate(true);
}

//毎フレーム呼び出される関数
void ARing::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

	if (m_pColorLightComp && m_pRingMesh)
	{
		//リングの色を更新
		m_pRingMesh->SetVectorParameterValueOnMaterials(TEXT("EmissiveColor"), m_pColorLightComp->GetVectorColor());
	}
	m_pRingMesh->SetGenerateOverlapEvents(isDraw());
	m_pRingMesh->SetHiddenInGame(!isDraw());
	//リングが通過されたなら
	if (m_bIsPassed)
	{
		//エフェクトの色をメッシュと同じ色にする
		m_pNiagaraEffectComp->SetNiagaraVariableLinearColor(TEXT("User.MeshColor"), m_pColorLightComp->GetVectorColor());
		if (m_MakeInvisibleTime > m_MakeInvisibleCnt)
		{
			//完全に見えなくなるまで時間をカウント
			m_MakeInvisibleCnt += DeltaTime;
			if (m_pRingMesh && m_pNiagaraEffectComp)
			{
				//メッシュとエフェクトの不透明度を下げていく
				const float CountRate = FMath::Clamp(m_MakeInvisibleCnt / m_MakeInvisibleTime, 0.f, 1.f);
				const float Opacity = FMath::Lerp(1.f, 0.f, CountRate);
				m_pRingMesh->SetScalarParameterValueOnMaterials(TEXT("Opacity"), Opacity);
				m_pNiagaraEffectComp->SetNiagaraVariableFloat(TEXT("User.MeshOpacity"), Opacity);

				if (Opacity <= 0.f)
				{
					//リングが見えなくなったら破棄する
					this->Destroy();
				}
			}
		}
	}
}

bool ARing::isDraw()
{
	if (!m_Drone)
		return false;

	return  (m_RingNumber - m_Drone->GetRingAcquisition() <= m_RingDrawUpNumber ? true : false);
}

//オーバーラップ開始時に呼ばれる処理
void ARing::OnOverlapBegin(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
	//タグがPlayerだった場合
	if (OtherActor->ActorHasTag(TEXT("Drone")))
	{
		//このリングがまだ通過されていない場合
		if (!m_bIsPassed)
		{
			if (m_pNiagaraEffectComp)
			{
				//通過された状態に変更
				m_bIsPassed = true;
				//エフェクトの再生
				m_pNiagaraEffectComp->Activate();
			}
		}
	}
}

